function [cp,ce,pv,ev] = makedual2(pp,tt,varargin)
%MAKEDUAL2 make dual complex for a conforming 2-simplex tri-
%angulation embedded in R^3.
%   [CP,CE,PV,EV] = MAKEDUAL2(PP,TT) returns the dual mesh
%   associated with an underlying simplicial triangulation.
%   The triangulation is defined as an N-by-3 set of nodal 
%   coordinates PP = [XI,YI,ZI] and an M-by-3 set of simplex 
%   indices TT = [PI,PJ,PK].
%
%   The resulting dual mesh is returned as a set of dual 
%   nodal coordinates PV = [XI,YI,ZI], a set of dual edge 
%   indices EV = [PI,PJ], and a set of dual cells. The CI-th 
%   cell contains the edges EV(CE(CP(CI,2):CP(CI,3)),:) and 
%   is centred about the primal node PP(CP(CI,1),:).
%
%   [...] = MAKEDUAL2(PP,TT,EC) imposes an additional set of 
%   edge constraints EC = [PI,PJ], ensuring that dual cells
%   are split about such edges. Additional implicit edge co-
%   nstraints are also applied, and include any topological-
%   ly or geometrically non-manifold edges in the underlying 
%   triangulation.
%
%   [...] = MAKEDUAL2(PP,TT,EC,OP) passes an additional user
%   -defined options structure. OP.ATOL = COS(THETA), where
%   THETA is the dihedral angle threshold defining geometri-
%   cally non-maifold edges. OP.ETOL is a length-based tole-
%   rance used to remove small edges in the dual cells. 
%   Specifically, Lmin(CI) > OP.ETOL * Lmax(CI) for each 
%   dual cell CI, where [Lmin,Lmax] are the minimum/maximum
%   associated edge lengths. By default OP.ETOL = +1.E-008
%   and OP.ATOL = +.5 [60 deg].
%
%   The dual complex generated by this routine is a "genera-
%   lised" variant, and ensures that a valid dual complex is 
%   obtained for any conforming triangulation, even those 
%   that are non-Delaunay. Specifically, each cell CI is gu-
%   aranteed to be "star-shaped" w.r.t. its associated prim-
%   al node PP(CP(CI,1),:). The dual complex is equivalent 
%   to the Voronoi diagram when the underlying triangulation 
%   is "well-centred", that is, when each simplex contains 
%   its own circumcentre. While the "generalised" dual comp-
%   lex does not always satisfy the same orthogonality cond-
%   itions as Voronoi-based duals, it is significantly more 
%   robust.
%
%   See also DEMODUAL2, DRAWDUAL2, GEOMDUAL2, TRIADUAL2

%   Dual vertices are either: (i) centres of circumballs 
%   (Voronoi), (ii) centres of min-enclosing balls, or (iii)
%   edge mid-points. Type (i) vertices are prefered, and are 
%   used when they lie within the hull of their associated
%   simplex. Type (ii) vertices are used otherwise, ensuring
%   that a valid, non-intersecting complex isgenerated for 
%   non-Delaunay triangulations. Additional type (iii) vert-
%   ices are added only when necessary to ensure that each 
%   cell is star-shaped w.r.t. its primal vertex. Dual cells 
%   are not guaranteed to be convex as a result, though they 
%   almost always are in practice. A valid, conforming and 
%   non-intersecting dual complex is guaranteed given any 
%   valid, conforming and non-intersecting input triangulat-
%   ion, even those incorporating very low-quality and/or 
%   non-Delaunay elements. The conventional "clipped" Voron-
%   oi diagram is recovered as triangulation quality improv-
%   es, and is recovered exactly when the triangulation is
%   "well-centred". Dual cells are "clipped" about non-mani-
%   fold or constrained edges.

%   Darren Engwirda : 2014 --
%   Email           : engwirda@mit.edu
%   Last updated    : 17/12/2014

%----------------------------------- extract optional inputs
    ec = []; op = [];
    if (nargin < +2 || nargin > +4)
        error('makedual:incorrectNumInputs','Incorrect number of inputs. ');
    end
    if (nargin >= +3), ec = varargin{1}; end
    if (nargin >= +4), op = varargin{2}; end
%---------------------------------------------- basic checks    
    if (~isfloat(pp) || ...
       (~isempty(tt) && ~isnumeric(tt)) || ...
       (~isempty(ec) && ~isnumeric(ec)) || ...
       (~isempty(op) && ~isstruct(op))) 
        error('makedual:incorrectInputClass','Incorrect input class.') ;
    end
%---------------------------------------------- basic checks
    if (ndims(pp) ~= +2 || size(pp,2) < +2 || size(pp,2) > +3)
        error('makedual:incorrectDimensions','Incorrect input dimensions.');
    end
    if (ndims(tt) ~= +2 || size(tt,2) ~= +3)
        error('makedual:incorrectDimensions','Incorrect input dimensions.');
    end
    if (~isempty(ec))
    if (ndims(ec) ~= +2 || size(ec,2) ~= +2)
        error('makedual:incorrectDimensions','Incorrect input dimensions.');
    end
    end
%------------------ lift R^2 inputs onto the xy-plane in R^3
    if (size(pp,2) == +2)
        pp = [pp, zeros(size(pp,1),1)] ;
    end
%---------------------------- deal with user-defined options
    if (~isstruct(op))
        op.etol = +1.e-008;
        op.atol = +1./+2. ;
    else
    %--------------------------------- bound merge tolerance
    if (isfield(op,'etol'))
        if (op.etol < +.0 || op.etol > +1.)
            error('makedual:invalidInputs','Invalid options.');
        end
    else
        op.etol = +1.e-008;
    end
    %--------------------------------- bound angle tolerance
    if (isfield(op,'atol'))
        if (op.atol < -1. || op.atol > +1.)
            error('makedual:invalidInputs','Invalid options.');
        end
    else
        op.atol = +1./+2. ;
    end
    end
%---------------------------------- check for valid indexing
    if (~isempty(tt))
    if ( min(min(tt)) < +1 || max(max(tt)) > size(pp,1))
        error('makedual:invalidTopology','Invalid triangulation. ');
    end
    end
    if (~isempty(ec))
    if ( min(min(ec)) < +1 || max(max(ec)) > size(pp,1))
        error('makedual:invalidTopology','Invalid constraint set.');
    end
    end
 
    [np] = size(pp,1);
    [nt] = size(tt,1);
%------------------------------------ form tria connectivity
    [ee,te,ep,et] = triaconn2(tt);
%------------------------------------ mark nonmanifold edges      
    [ke] = markedge(ee,ep,et,ec,pp,tt,op);
%------------------------------------ form tria circum-balls
    [cc] = miniball2(pp,tt);
%-------------------------------------------- edge midpoints    
    [pm] = (pp(ee(:,1),:) + ...
            pp(ee(:,2),:))*+.5;
%-------------------------------------------- node positions
    [pv] = [pp; cc(:,1:3); pm];
%-------------------------------- make edges in dual complex
    [ev] = makeedge(ee,ep,et,ke,pv,np,nt);
%-------------------------------------- remove "short" edges
    [pv,ev] = healedge(pv,ev,op);
%-------------------------------------- remove un-used nodes
    [pv,ev] = healnode(pv,ev,np);
%-------------------------------- make cells in dual complex
    [cp,ce] = clipcell(ev)  ;
%--------------------------------------- dump extra indexing
    [ev] = ev(:,1:2);
   
end

function [ke] = markedge(ee,ep,et,ec,pp,tt,op)
%% mark any constrained/non-manifold edges in tria

%------------------------------------ mark constrained edges
    if (~isempty(ec))
        ke = ismember(ee,sort(ec,2),'rows') ;
    else
        ke = zeros(size(ee,1),1);
    end
%------------------------------------ find nonmanifold edges
    for ei = 1 : size(ee,1)
    %-------------------------------------------- adj. nodes
        ni = ee(ei,1);
        nj = ee(ei,2);
    %-------------------------------- mark nonmanifold edges
        if (ep(ei,2)-ep(ei,1) == +1)
        %---------------------------------------- adj. trias    
            ti = et(ep(ei,1)+0) ;
            tj = et(ep(ei,1)+1) ;
        %-------------------------- find adj. nodes in ti,tj
            na = +0; nb = +0;
            for ii = 1 : 3
            %------------------------------- adj. node in ti
                if (tt(ti,ii) ~= ni && ...
                    tt(ti,ii) ~= nj )
                    na = tt(ti,ii);
                end
            %------------------------------- adj. node in tj
                if (tt(tj,ii) ~= ni && ...
                    tt(tj,ii) ~= nj )
                    nb = tt(tj,ii);
                end
            end
        %------------------------------- calc. local normals    
            ab(1) = pp(nj,1)-pp(na,1);
            ab(2) = pp(nj,2)-pp(na,2);
            ab(3) = pp(nj,3)-pp(na,3);
            ac(1) = pp(ni,1)-pp(na,1);
            ac(2) = pp(ni,2)-pp(na,2);
            ac(3) = pp(ni,3)-pp(na,3);
            n1(1) = ab(2)*ac(3) - ...
                    ab(3)*ac(2) ;
            n1(2) = ab(3)*ac(1) - ...
                    ab(1)*ac(3) ;
            n1(3) = ab(1)*ac(2) - ...
                    ab(2)*ac(1) ;
        %------------------------------- calc. local normals
            ab(1) = pp(ni,1)-pp(nb,1);
            ab(2) = pp(ni,2)-pp(nb,2);
            ab(3) = pp(ni,3)-pp(nb,3);
            ac(1) = pp(nj,1)-pp(nb,1);
            ac(2) = pp(nj,2)-pp(nb,2);
            ac(3) = pp(nj,3)-pp(nb,3);
            n2(1) = ab(2)*ac(3) - ...
                    ab(3)*ac(2) ;
            n2(2) = ab(3)*ac(1) - ...
                    ab(1)*ac(3) ;
            n2(3) = ab(1)*ac(2) - ...
                    ab(2)*ac(1) ;
        %---------------- cosine of dihedral angle (squared)
            l1 = +n1(1) * n1(1) + ...
                 +n1(2) * n1(2) + ...
                 +n1(3) * n1(3) ;
            l2 = +n2(1) * n2(1) + ...
                 +n2(2) * n2(2) + ...
                 +n2(3) * n2(3) ;
            aa = +n1(1) * n2(1) + ...
                 +n1(2) * n2(2) + ...
                 +n1(3) * n2(3) ;
            aa = aa / sqrt(l1*l2) ;
        %------------------ geometrically non-manifold edges
            if (aa < op.atol)
            ke(ei) = +3; 
            end     
        %------------------ _topologically non-maifold edges
        else
            ke(ei) = +2;
        end
    end 

end

function [ev] = makeedge(ee,ep,et,ke,pv,np,nt)
%% assemble edge segments in cells od dual complex

    nn = ep(:,2)-ep(:,1)+1 ;
    ev = zeros(sum(nn)*3,4);
%---------------------------- assemble edges in dual complex  
    ne = +0;
    for ei = 1 : size(ee,1)
    %-------------------------------------------- adj. nodes
        ni = ee(ei,1);
        nj = ee(ei,2);
        mi = ei+nt+np;
    %----------------------------------- assemble dual cells
        if (ke(ei) == +0)
        %---------------------------------------- adj. trias    
            ti = et(ep(ei,1)+0)+np;
            tj = et(ep(ei,1)+1)+np;
        %------------------------------- calc. local normals
            ab(1) = pv(tj,1)-pv(ni,1);
            ab(2) = pv(tj,2)-pv(ni,2);
            ab(3) = pv(tj,3)-pv(ni,3);
            ac(1) = pv(ti,1)-pv(ni,1);
            ac(2) = pv(ti,2)-pv(ni,2);
            ac(3) = pv(ti,3)-pv(ni,3);
            n1(1) = ab(2)*ac(3) - ...
                    ab(3)*ac(2) ;
            n1(2) = ab(3)*ac(1) - ...
                    ab(1)*ac(3) ;
            n1(3) = ab(1)*ac(2) - ...
                    ab(2)*ac(1) ;
        %------------------------------- calc. local normals
            ab(1) = pv(ti,1)-pv(nj,1);
            ab(2) = pv(ti,2)-pv(nj,2);
            ab(3) = pv(ti,3)-pv(nj,3);
            ac(1) = pv(tj,1)-pv(nj,1);
            ac(2) = pv(tj,2)-pv(nj,2);
            ac(3) = pv(tj,3)-pv(nj,3);
            n2(1) = ab(2)*ac(3) - ...
                    ab(3)*ac(2) ;
            n2(2) = ab(3)*ac(1) - ...
                    ab(1)*ac(3) ;
            n2(3) = ab(1)*ac(2) - ...
                    ab(2)*ac(1) ;
        %----------------------- deal with segment selection    
            if (n1(1)*n2(1) + ...
                n1(2)*n2(2) + ...
                n1(3)*n2(3)>=+.0)
        %------------------------ add dual tria-tria segment
            ne = ne+1;
            ev(ne,1) = ti ;
            ev(ne,2) = tj ;
            ev(ne,3) = ni ;
            ev(ne,4) = nj ;
            else
        %------------------------ add dual tria-edge segment
            ne = ne+1;
            ev(ne,1) = ti ;
            ev(ne,2) = mi ;
            ev(ne,3) = ni ;
            ev(ne,4) = nj ;
            ne = ne+1;
            ev(ne,1) = mi ;
            ev(ne,2) = tj ;
            ev(ne,3) = ni ;
            ev(ne,4) = nj ;
            end
    %--------------------------- deal with nonmanifold edges
        else
        %------------------------ add dual node-edge segment
            ne = ne+1;
            ev(ne,1) = mi ;
            ev(ne,2) = ni ;
            ev(ne,3) = ni ;
            ev(ne,4) = +0 ;
            ne = ne+1;
            ev(ne,1) = nj ;
            ev(ne,2) = mi ;
            ev(ne,3) = nj ;
            ev(ne,4) = +0 ;
            for ti = ep(ei,1) : ep(ei,2)
        %------------------------ add dual tria-edge segment
            tc = et(ti);
            tc = tc+np ;
            ne = ne+1;
            ev(ne,1) = tc ;
            ev(ne,2) = mi ;
            ev(ne,3) = ni ;
            ev(ne,4) = nj ;
            end
        end
    end
%-------------------------------- trim allocation per demand
    ev = ev(1:ne,:);

end

function [pv,ev] = healedge(pv,ev,op)
%% remove overly short edges by merging adj. nodes.

%---------------------------------------- calc. edge lengths
    el = sum((pv(ev(:,2),:)-pv(ev(:,1),:)).^2,2);
%---------------------------------------- calc. cell measure
    nc = max(max(ev(:,3:4)));
    cl = zeros(nc*1,1);
    for ei = 1 : size(ev,1)
        for ii = 3 : 4
    %--------------------------------------------- adj. cell
        ci = ev(ei,ii) ;
    %--------------------------------------------- null cell
        if (ci <= +1), continue; end
    %--------------------------------------- keep max so far
        if (el(ei) > cl(ci))
            cl(ci) = el(ei); 
        end
        end
    end
    cl = cl * op.etol * ...
              op.etol ;
%-------------------------- collapse small edges/merge nodes
    ki = zeros(size(pv,1),1);
    for ei = 1 : size(ev,1)
    %--------------------------------------------- adj. node
        ni = ev(ei,1);
        nj = ev(ei,2);
    %-------------------------------- chase node re-indexing
        while (ki(ni) > +0), ni = ki(ni); end
        while (ki(nj) > +0), nj = ki(nj); end
    %-------------------------------- skip already collapsed
        if (ni == nj), continue; end
    %--------------------------------------- scan adj. cells
        for ii = 3 : 4
    %--------------------------------------------- adj. cell
        ci = ev(ei,ii) ;
    %--------------------------------------------- null cell
        if (ci <= +1), continue; end 
    %------------------------ collapse if sufficiently small
        lx = pv(nj,1)-pv(ni,1);
        ly = pv(nj,2)-pv(ni,2);
        lz = pv(nj,3)-pv(ni,3);
        ll = lx * lx + ...
             ly * ly + ...
             lz * lz ;
        if (ll < cl(ci))
        %------------------------------- merge node position
            pv(ni,1) = (pv(ni,1)+pv(nj,1))*+.5 ;
            pv(ni,2) = (pv(ni,2)+pv(nj,2))*+.5 ;
            pv(ni,3) = (pv(ni,3)+pv(nj,3))*+.5 ;
        %------------------------------- merge node indexing
            ki(nj) = ni; break ;
        end
        end
    end
%-------------------------------- remove any collapsed edges
    ne = +1;
    for ei = 1 : size(ev,1)
    %--------------------------------------------- adj. node
        ni = ev(ei,1);
        nj = ev(ei,2);
    %--------------------------------------------- adj. cell
        ci = ev(ei,3);
        cj = ev(ei,4);
    %-------------------------------- chase node re-indexing
        while (ki(ni) > +0), ni = ki(ni); end
        while (ki(nj) > +0), nj = ki(nj); end
    %-------------------------------- keep un-collapsed edge
        if (ni ~= nj)
            ev(ne,1) = ni;
            ev(ne,2) = nj;
            ev(ne,3) = ci;
            ev(ne,4) = cj;
            ne = ne + 1;
        end
    end
    ev = ev(1:ne-1,:);
    
end

function [pv,ev] = healnode(pv,ev,np)
%% remove un-referenced nodes from set and re-index.

%------------------------------------- mark referenced nodes
    ki = zeros(size(pv,1),+1);
    ki(+1:np) = +1;
    ki(ev(:,1:2)) = +1;
%------------------------------------- keep referenced nodes
    pv = pv(ki==+1,:);
%------------------------------------------ init re-indexing    
    ki(ki==+1) = 1:size(pv,1);
%------------------------------------------ edge re-indexing
    ev(:,1:2) = ki(ev(:,1:2));
    
end

function [cp,ce] = clipcell(ev)
%% build dual cells - clip about non-manifold edges.

%------------------------------------ triangulate dual cells
    tv = zeros(size(ev,1)*2,3); nt = +1 ;
    for ei = 1 : size(ev,1)
        for ii = 3 : 4
        %----------------------------------------- cell node
            ni = ev(ei,ii);
        %-------------------------------- skip if constraint    
            if (ni <= +0 ), continue; end
        %----------------------------------------- edge node
            nj = ev(ei,1);
            nk = ev(ei,2);    
        %-------------------------------- skip if degenerate
            if (ni == nj || ...
                ni == nk ), continue; end
        %----------------------------------------- push tria
            tv(nt,1) = ni;
            tv(nt,2) = nj;
            tv(nt,3) = nk;
            nt = nt+1;
        end
    end
    tv = tv(1:nt-1,:);
    
%------------------------------------------ edge-tria conn.
    [ee,te,ep,et] = triaconn2(tv);   
    
%------------------------------------------ mark cell edges
    [ef,em] = ismember(sort(ee,2),sort(ev(:,1:2),2),'rows') ;
  
%----------------------------------- assemble clipped cells
    cp = zeros(size(tv,1)*1,3); nc = +1;
    ce = zeros(size(tv,1)*1,1); ne = +1;
    kt = zeros(size(tv,1)*1,1);
    ts = zeros(size(tv,1)*1,1);
    for ti = 1 : size(tv)
        if (kt(ti) ~= +0), continue; end
    %-------------------------------------------- cell node
        ni = tv(ti,1);
    %-------------------------------------------- cell ptrs
        cp(nc,1) = ni;
        cp(nc,2) = ne;
    %-------------------------------- assemble cell via bfs
        ns = +1; 
        ts(ns) = ti;
        kt(ti) = +1;     
        while (ns ~= +0)
        %----------------------------------- _pop bfs stack
            tj = ts(ns);
            ns = ns - 1;
        %----------------------------------- scan tria adj.    
            for ei = 1 : 3          
                ej = te(tj,ei) ;
                if (em(ej)~=0)
            %---------------------- push external cell edge
                    ce(ne) = em(ej); ne = ne+1;  
                else
            %----------------------------- must be manifold
                    if (tj ~= et(ep(ej,1)))
                        tk  = et(ep(ej,1));
                    else
                        tk  = et(ep(ej,2));
                    end
            %----------------------------- walk to adjacent
                    if (kt(tk)==0)
                        ns = ns+1;
                        ts(ns)=tk;
                        kt(tk)=+1;     
                    end
                end
            end
        end
    %------------------------------------------ update ptrs
        cp(nc,3) = ne - 1; nc = nc + 1;     
    end
%---------------------------------------------- trim alloc.
    cp = cp(1:nc-1,:) ;
    ce = ce(1:ne-1,:) ;
    
end

